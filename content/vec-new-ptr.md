# 新创建的空 `Vec<T>` 的指针为何指向`1`、`2`、`4`、`8`等地址？

当 `Vec` 的容量为0时，没有合法的操作会向其指针指向的位置进行读取和写入，进行任何读写之前都必然会有一次内存分配，因此这个初始的指针并不需要是一个有效的指针。这也使得创建 `Vec` 本身没有进行实际内存分配的必要，既省去了内存分配的开销，也让创建容器的操作可以在常量上下文中使用。

而由于这个指针在类型上依然是指向 `T` 的指针，它必须有正确的[对齐]，因此简单起见便选择了类型的对齐的大小作为这个无效指针指向的地址。

空指针也满足上面的要求，为何这个初始指针不是一个空指针呢？

这是因为Rust有[空指针优化]的惯例：对于各种类似指针的类型如 `&T`、`&mut T`、`Box<T>`，将它们包进 `Option` 里不会改变它们的大小，即 `Option<Box<T>>` 与 `Box<T>` 的大小是相同的。而这个优化的机理就是要求这些类型不能指向`0`，使得`0`这个值可以被 `None` 分支所使用。这一优化是来源于Rust对[零开销抽象]和[空指针安全]的要求，它保证了人们可以使用 `Option` 替代可为空的指针而不需要付出额外的运行时代价。

`Vec` 虽然不是一个指针类型，但其内部使用的指针也遵循了同样的惯例，这也让 `Option<Vec<T>>` 与 `Vec<T>` 的大小是一致的。
