<!DOCTYPE html>
<html lang="zh-CN">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rust 常见疑问汇总</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="highlight.css">
<header>
  <h1>Rust 常见疑问汇总</h1>
</header>
<main>
  <article>
    <h2 id="binary-size"><a href="#binary-size">为什么 Rust 生成的程序体积比较大？如何最小化程序体积？</a></h2><p>有多个因素使得 Rust 在默认情况下有着相对较大的程序体积，包括了单态化、调试符号、标准库等。一般来说，Rust 偏向于为性能优化而非更小的体积。</p><p>通常使用发布模式编译（<code>--release</code>），以及（在 Linux 和 macOS 下）使用 <code>strip</code> 删除符号信息可以在一定程度上缩小程序体积。更多方法可以参考 <a href="https://github.com/johnthagen/min-sized-rust">Minimizing Rust Binary Size</a>，对这一问题有较完整的介绍。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/binary-size.md">编辑</a>
  </article>
  <article>
    <h2 id="error-handling"><a href="#error-handling">错误处理推荐使用什么库？</a></h2><p>目前一般认为对于应用程序推荐使用 <a href="https://crates.io/crates/anyhow"><code>anyhow</code></a>，而对于库推荐使用 <a href="https://crates.io/crates/thiserror"><code>thiserror</code></a>。</p><p><code>anyhow</code> 提供了一个基于 trait 对象的错误类型，可以很容易地将不同来源的错误统一到单一来源，并可以方便地为错误添加上下文，以及就地创建新的错误。</p><p><code>thiserror</code> 则提供了一个 derive 宏，方便为自定义的错误类型实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/error-handling.md">编辑</a>
  </article>
  <article>
    <h2 id="format-macro"><a href="#format-macro">格式化字符串的方法，如 <code>println</code>、<code>info</code> 等一般通过宏来实现，这是为什么？</a></h2><p>因为 Rust 里函数不支持变长参数，因而如果要做编译期类型检查，就必须通过宏来实现。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/format-macro.md">编辑</a>
  </article>
  <article>
    <h2 id="future-poll-perf"><a href="#future-poll-perf">Rust 的 <code>Future</code> 是基于轮询的，这种方式不会有性能问题吗？</a></h2><p><code>Future</code> 的轮询是带通知机制的轮询，与传统意义上的轮询不完全一样。</p><p>当执行器（executor）调用 <code>Future</code> 的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll"><code>poll</code></a> 方法时会传入一个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>，而 <code>Future</code> 可以将这个 <code>Waker</code> 保存起来，当自己的状态有所变化时，通过其通知执行器可以再次对自己进行轮询。通过这个机制，执行器可以避免反复轮询一个未准备好的 <code>Future</code>，避免了传统轮询带来的性能问题。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/future-poll-perf.md">编辑</a>
  </article>
  <article>
    <h2 id="futures-rel"><a href="#futures-rel">标准库的 <code>Future</code>、<code>futures</code> crate、<code>tokio</code> 和 <code>async-std</code> 等之间的关系是什么？</a></h2><p>标准库的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> trait 以及相关的 <a href="https://doc.rust-lang.org/std/task/struct.Context.html"><code>Context</code></a>、<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a>、<a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 等是核心。由于编译器编译异步函数（<code>async fn</code>）需要依赖它们的定义，因而它们必须被包含在标准库里。</p><p><a href="https://crates.io/crates/futures"><code>futures</code></a> 是 <code>Future</code> 的扩展，提供了许多虽不必进入标准库但依然重要的基础性的东西，比如 <a href="https://docs.rs/futures/*/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>、<a href="https://docs.rs/futures/*/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a> 等扩展 trait 和基础的<a href="https://docs.rs/futures/*/futures/channel/index.html">通道</a>、<a href="https://docs.rs/futures/*/futures/executor/index.html">执行器</a>实现等。</p><p><a href="https://crates.io/crates/tokio"><code>tokio</code></a> 和 <a href="https://crates.io/crates/async-std"><code>async-std</code></a> 是同一个层次的，主要提供异步运行时的实现，都依赖 <code>futures</code> 提供的元语，但因为处理的层次不同，所以可以看到一些自定义的与 <code>futures</code> 差不多的模块。</p><p>此外，虽然目前 <a href="https://docs.rs/futures/*/futures/stream/trait.Stream.html"><code>Stream</code></a> 是由 <code>futures</code> 提供的，但未来如果编译器要实现<a href="https://rust-lang.github.io/rfcs/2394-async_await.html#generators-and-streams">异步生成器</a>（async generator），这个 trait 也很可能会进入标准库，因而对其的扩展也依然放进了独立的 <code>StreamExt</code> 里。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/futures-rel.md">编辑</a>
  </article>
  <article>
    <h2 id="trait-obj-upcast"><a href="#trait-obj-upcast">如果有一个 <code>trait Foo: Base</code>，如何将一个 <code>&amp;dyn Foo</code> 转换到 <code>&amp;dyn Base</code>？</a></h2><p>Rust 目前不直接提供这种转换，如果需要转换可以使用一个中间 trait 来实现，如</p><pre class="code"><span class="s-source s-rust"><span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Base</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">AsBase</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span></span><span class="s-punctuation s-terminator s-rust">;</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-impl s-rust"><span class="s-storage s-type s-impl s-rust">impl</span></span><span class="s-meta s-impl s-rust"><span class="s-meta s-generic s-rust"><span class="s-punctuation s-definition s-generic s-begin s-rust">&lt;</span>T<span class="s-punctuation s-separator s-rust">:</span> Base<span class="s-punctuation s-definition s-generic s-end s-rust">&gt;</span></span></span><span class="s-meta s-impl s-rust"> AsBase <span class="s-keyword s-other s-rust">for</span></span><span class="s-meta s-impl s-rust"> <span class="s-entity s-name s-impl s-rust">T</span> </span><span class="s-meta s-impl s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span> </span><span class="s-meta s-function s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span> <span class="s-variable s-language s-rust">self</span> </span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Foo</span>: AsBase <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span></pre><p>不支持的主要原因是在 trait 对象的虚表中没有相应的数据指向另一个 trait 的虚表，而不提供相应数据的原因可能是由于这很容易产生过多无用的虚表，进而导致二进制体积的膨胀。</p><p>更多关于这一话题的讨论可以参考 <a href="https://github.com/rust-lang/rfcs/issues/2765">RFC 2765</a> 以及 <a href="https://articles.bchlr.de/traits-dynamic-dispatch-upcasting">Traits, dynamic dispatch and upcasting</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/trait-obj-upcast.md">编辑</a>
  </article>
  </main>
<footer>
  <a class="telegram" href="https://t.me/rust_zh">Rust 众</a>
  <a rel="license" class="cc0" href="https://creativecommons.org/publicdomain/zero/1.0/deed.zh">CC0</a>
</footer>
</html>
