<!DOCTYPE html>
<html lang="zh-CN">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Rust 常见疑问汇总</title>
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="highlight.css">
<header>
  <h1>Rust 常见疑问汇总</h1>
</header>
<main>
  <article>
    <h2 id="async-fn-in-trait"><a href="#async-fn-in-trait">如何在特质里添加异步函数？</a></h2><p>目前 Rust 不支持在<a title="trait">特质</a>里直接添加<a title="async function">异步函数</a>，但可以使用 <a href="https://crates.io/crates/async-trait">async-trait</a> 这个库来实现。这个库会将异步函数改写为返回 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 的普通函数以绕过目前语言层面的限制，但也因此有堆分配以及<a title="dynamic dispatch">动态分发</a>这两个额外的代价，所以不会被直接添加到 Rust 语言中。</p><p>在特质里不支持使用异步函数是由于异步函数本质上是一个返回 <code>impl Future&lt;Output = T&gt;</code> 的函数，而目前 Rust 的类型系统还无法表达在特质的方法的返回类型上使用 <code>impl Trait</code>。有两个已经通过的 RFC 旨在解决这一问题：<a href="https://rust-lang.github.io/rfcs/1598-generic_associated_types.html">RFC 1598</a> 泛型关联类型和 <a href="https://rust-lang.github.io/rfcs/2071-impl-trait-existential-types.html">RFC 2071</a> <code>impl Trait</code> <a title="existential type">存在类型</a>，但它们的编译器支持还在实现中。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/async-fn-in-trait.md">编辑</a>
  </article>
  <article>
    <h2 id="binary-size"><a href="#binary-size">为什么 Rust 生成的程序体积比较大？如何最小化程序体积？</a></h2><p>有多个因素使得 Rust 在默认情况下有着相对较大的程序体积，包括了<a title="monomorphization">单态化</a>、调试符号、标准库等。一般来说，Rust 偏向于为性能优化而非更小的体积。</p><p>通常使用发布模式编译（<code>--release</code>），以及（在 Linux 和 macOS 下）使用 <code>strip</code> 删除符号信息可以在一定程度上缩小程序体积。更多方法可以参考 <a href="https://github.com/johnthagen/min-sized-rust">Minimizing Rust Binary Size</a>，对这一问题有较完整的介绍。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/binary-size.md">编辑</a>
  </article>
  <article>
    <h2 id="common-ide"><a href="#common-ide">写 Rust 有哪些常用的开发环境？</a></h2><p>目前来看，最流行的 Rust 开发环境是 <a href="https://code.visualstudio.com/">Visual Studio Code</a> 配合 <a href="https://rust-analyzer.github.io/">rust-analyzer</a>，其次是在 <a href="https://www.jetbrains.com/clion/">CLion</a> 或其他 <a href="https://www.jetbrains.com/products.html#type=ide">IntelliJ</a> 平台的 IDE 上安装 <a href="https://intellij-rust.github.io/">Intellij Rust</a> 插件。使用 <a href="https://www.vim.org/">Vim</a> 或 <a href="https://www.gnu.org/software/emacs/">Emacs</a> 进行开发的也不在少数，此外也有人使用其他编辑器。</p><p>Rust 群关于这一问题有定期调查：</p><ul><li>2020年：<a href="https://t.me/c/1264662201/96391">5月</a>、<a href="https://t.me/c/1264662201/116314">8月</a>、<a href="https://t.me/c/1264662201/130996">11月</a></li><li>2021年：<a href="https://t.me/c/1264662201/147028">2月</a></li></ul>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/common-ide.md">编辑</a>
  </article>
  <article>
    <h2 id="error-handling"><a href="#error-handling">错误处理推荐使用什么库？</a></h2><p>目前一般认为对于应用程序推荐使用 <a href="https://crates.io/crates/anyhow">anyhow</a>，而对于库推荐使用 <a href="https://crates.io/crates/thiserror">thiserror</a>。</p><p>anyhow 提供了一个基于<a title="trait object">特质对象</a>的错误类型，可以很容易地将不同来源的错误统一到单一来源，并可以方便地为错误添加上下文，以及就地创建新的错误。</p><p>thiserror 则提供了一个 derive 宏，方便为自定义的错误类型实现 <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> 特质</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/error-handling.md">编辑</a>
  </article>
  <article>
    <h2 id="format-macro"><a href="#format-macro">格式化字符串的方法，如 <code>println</code>、<code>info</code> 等一般通过宏来实现，这是为什么？</a></h2><p>因为 Rust 里函数不支持变长参数，因而如果要做编译期类型检查，就必须通过宏来实现。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/format-macro.md">编辑</a>
  </article>
  <article>
    <h2 id="future-poll-perf"><a href="#future-poll-perf">Rust 的 <code>Future</code> 是基于轮询的，这种方式不会有性能问题吗？</a></h2><p><code>Future</code> 的轮询是带通知机制的轮询，与传统意义上的轮询不完全一样。</p><p>当<a title="executor">执行器</a>调用 <code>Future</code> 的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html#tymethod.poll"><code>poll</code></a> 方法时会传入一个 <a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a>，而 <code>Future</code> 可以将这个 <code>Waker</code> 保存起来，当自己的状态有所变化时，通过其通知执行器可以再次对自己进行轮询。通过这个机制，执行器可以避免反复轮询一个未准备好的 <code>Future</code>，避免了传统轮询带来的性能问题。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/future-poll-perf.md">编辑</a>
  </article>
  <article>
    <h2 id="futures-rel"><a href="#futures-rel">标准库的 <code>Future</code>、futures crate、tokio 和 async-std 等之间的关系是什么？</a></h2><p>标准库的 <a href="https://doc.rust-lang.org/std/future/trait.Future.html"><code>Future</code></a> <a title="trait">特质</a>以及相关的 <a href="https://doc.rust-lang.org/std/task/struct.Context.html"><code>Context</code></a>、<a href="https://doc.rust-lang.org/std/pin/struct.Pin.html"><code>Pin</code></a>、<a href="https://doc.rust-lang.org/std/task/struct.Waker.html"><code>Waker</code></a> 等是核心。由于编译器编译<a title="async function">异步函数</a>需要依赖它们的定义，因而它们必须被包含在标准库里。</p><p><a href="https://crates.io/crates/futures">futures</a> 是 <code>Future</code> 的扩展，提供了许多虽不必进入标准库但依然重要的基础性的东西，比如 <a href="https://docs.rs/futures/*/futures/future/trait.FutureExt.html"><code>FutureExt</code></a>、<a href="https://docs.rs/futures/*/futures/stream/trait.StreamExt.html"><code>StreamExt</code></a> 等扩展特质和基础的<a href="https://docs.rs/futures/*/futures/channel/index.html">通道</a>、<a href="https://docs.rs/futures/*/futures/executor/index.html">执行器</a>实现等。</p><p><a href="https://crates.io/crates/tokio">tokio</a> 和 <a href="https://crates.io/crates/async-std">async-std</a> 是同一个层次的，主要提供异步运行时的实现，都依赖 futures 提供的元语，但因为处理的层次不同，所以可以看到一些自定义的与 futures 差不多的模块。</p><p>此外，虽然目前 <a href="https://docs.rs/futures/*/futures/stream/trait.Stream.html"><code>Stream</code></a> 是由 futures 提供的，但未来如果编译器要实现<a href="https://rust-lang.github.io/rfcs/2394-async_await.html#generators-and-streams" title="async generator">异步生成器</a>，这个特质也很可能会进入标准库，因而对其的扩展也依然放进了独立的 <code>StreamExt</code> 里。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/futures-rel.md">编辑</a>
  </article>
  <article>
    <h2 id="heap-new"><a href="#heap-new">如何直接在堆上分配新的对象或数组？</a></h2><p>目前 Rust 语言本身没有提供稳定且不使用 <code>unsafe</code> 的方式能保证将一个对象或数组直接分配到堆上。</p><p><code>Box::new([0; 4096])</code> 等方式在语义上是在栈上创建数组，然后再移动到堆上。<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code>Vec</code></a> 等容器类型的内容会直接分配在堆上，因而也可以通过 <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.into_boxed_slice"><code>Vec::into_boxed_slice</code></a> 从一个 <code>Vec</code> 得到堆上切片 <code>Box&lt;[T]&gt;</code>，再通过 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#impl-TryFrom%3CBox%3C%5BT%5D%3E%3E"><code>TryFrom</code></a> 获得堆上数组 <code>Box&lt;[T; N]&gt;</code>。不过添加每个元素从语义上依然是在栈上分配再移入容器的。</p><p>有一些第三方的库，如 <a href="https://crates.io/crates/copyless"><code>copyless</code></a>、<a href="https://crates.io/crates/boxext"><code>boxext</code></a> 和 <a href="https://crates.io/crates/default-boxed"><code>default-boxed</code></a> 等，通过依赖编译器优化或包装 <code>unsafe</code> 的功能来提供安全的接口进行直接分配。</p><p>使用 <code>unsafe</code> 的话可以通过调用 <a href="https://doc.rust-lang.org/std/alloc/fn.alloc.html"><code>alloc</code></a> 函数直接分配堆内存并取得指针，但需要手动初始化和管理分配的内存。<code>Box</code> 及其他智能指针类型未来很可能会提供 <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new_uninit"><code>new_uninit</code></a>、<a href="https://doc.rust-lang.org/std/boxed/struct.Box.html#method.new_uninit_slice"><code>new_uninit_slice</code></a> 等方法在堆上直接创建 <a href="https://doc.rust-lang.org/std/mem/union.MaybeUninit.html"><code>MaybeUninit</code></a>，但你仍将需要使用 <code>unsafe</code> 的方式来初始化其内容。</p><p>未稳定的 <a href="https://doc.rust-lang.org/nightly/unstable-book/language-features/box-syntax.html"><code>box</code> 语法</a>在一些情况下可以直接分配到堆上并创建一个 <code>Box</code>，但当有嵌套表达式，如 <code>box Wrapper([0; 4096])</code>，时则依然会有先分配在栈上再移入堆的问题。而且 <code>box</code> 语法目前也没有稳定化的计划。</p><p>此外，有一些提案，如 <a href="https://github.com/rust-lang/rfcs/pull/2884">RFC 2884</a>，试图提供新的接口来解决这一问题，但目前还没有足够的共识。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/heap-new.md">编辑</a>
  </article>
  <article>
    <h2 id="trait-obj-upcast"><a href="#trait-obj-upcast">如果有一个 <code>trait Foo: Base</code>，如何将一个 <code>&amp;dyn Foo</code> 转换到 <code>&amp;dyn Base</code>？</a></h2><p>Rust 目前不直接提供这种转换，如果需要转换可以使用一个中间<a title="trait">特质</a>来实现，如</p><pre class="code"><span class="s-source s-rust"><span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Base</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">AsBase</span> <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span></span><span class="s-punctuation s-terminator s-rust">;</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-impl s-rust"><span class="s-storage s-type s-impl s-rust">impl</span></span><span class="s-meta s-impl s-rust"><span class="s-meta s-generic s-rust"><span class="s-punctuation s-definition s-generic s-begin s-rust">&lt;</span>T<span class="s-punctuation s-separator s-rust">:</span> Base<span class="s-punctuation s-definition s-generic s-end s-rust">&gt;</span></span></span><span class="s-meta s-impl s-rust"> AsBase <span class="s-keyword s-other s-rust">for</span></span><span class="s-meta s-impl s-rust"> <span class="s-entity s-name s-impl s-rust">T</span> </span><span class="s-meta s-impl s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-meta s-function s-rust"><span class="s-meta s-function s-rust"><span class="s-storage s-type s-function s-rust">fn</span> </span><span class="s-entity s-name s-function s-rust">as_base</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-begin s-rust">(</span><span class="s-keyword s-operator s-rust">&amp;</span><span class="s-variable s-parameter s-rust">self</span></span><span class="s-meta s-function s-rust"><span class="s-meta s-function s-parameters s-rust"><span class="s-punctuation s-section s-parameters s-end s-rust">)</span></span></span></span><span class="s-meta s-function s-rust"> <span class="s-meta s-function s-return-type s-rust"><span class="s-punctuation s-separator s-rust">-&gt;</span> <span class="s-keyword s-operator s-rust">&amp;</span>dyn Base</span> </span><span class="s-meta s-function s-rust"><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span> <span class="s-variable s-language s-rust">self</span> </span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>

<span class="s-meta s-trait s-rust"><span class="s-storage s-type s-trait s-rust">trait</span> <span class="s-entity s-name s-trait s-rust">Foo</span>: AsBase <span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-begin s-rust">{</span>
    <span class="s-comment s-line s-double-slash s-rust"><span class="s-punctuation s-definition s-comment s-rust">//</span> ...</span>
</span><span class="s-meta s-block s-rust"><span class="s-punctuation s-section s-block s-end s-rust">}</span></span></span>
</span></pre><p>不支持的主要原因是在<a title="trait object">特质对象</a>的<a title="vtable">虚表</a>中没有相应的数据指向另一个特质的虚表，而不提供相应数据的原因可能是由于这很容易产生过多无用的虚表，进而导致二进制体积的膨胀。</p><p>更多关于这一话题的讨论可以参考 <a href="https://github.com/rust-lang/rfcs/issues/2765">RFC 2765</a> 以及 <a href="https://articles.bchlr.de/traits-dynamic-dispatch-upcasting">Traits, dynamic dispatch and upcasting</a>。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/trait-obj-upcast.md">编辑</a>
  </article>
  <article>
    <h2 id="vec-new-ptr"><a href="#vec-new-ptr">新创建的空 <code>Vec&lt;T&gt;</code> 的指针为何指向<code>1</code>、<code>2</code>、<code>4</code>、<code>8</code>等地址？</a></h2><p>当 <code>Vec</code> 的容量为0时，没有合法的操作会向其指针指向的位置进行读取和写入，进行任何读写之前都必然会有一次内存分配，因此这个初始的指针并不需要是一个有效的指针。这也使得创建 <code>Vec</code> 本身没有进行实际内存分配的必要，既省去了内存分配的开销，也让创建容器的操作可以在常量上下文中使用。</p><p>而由于这个指针在类型上依然是指向 <code>T</code> 的指针，它必须有正确的<a title="alignment">对齐</a>，因此简单起见便选择了类型的对齐的大小作为这个无效指针指向的地址。</p><p>空指针也满足上面的要求，为何这个初始指针不是一个空指针呢？</p><p>这是因为Rust有<a title="null pointer optimization">空指针优化</a>的惯例：对于各种类似指针的类型如 <code>&amp;T</code>、<code>&amp;mut T</code>、<code>Box&lt;T&gt;</code>，将它们包进 <code>Option</code> 里不会改变它们的大小，即 <code>Option&lt;Box&lt;T&gt;&gt;</code> 与 <code>Box&lt;T&gt;</code> 的大小是相同的。而这个优化的机理就是要求这些类型不能指向<code>0</code>，使得<code>0</code>这个值可以被 <code>None</code> 分支所使用。这一优化是来源于Rust对<a title="zero-cost abstractions">零开销抽象</a>和<a title="null safety">空指针安全</a>的要求，它保证了人们可以使用 <code>Option</code> 替代可为空的指针而不需要付出额外的运行时代价。</p><p><code>Vec</code> 虽然不是一个指针类型，但其内部使用的指针也遵循了同样的惯例，这也让 <code>Option&lt;Vec&lt;T&gt;&gt;</code> 与 <code>Vec&lt;T&gt;</code> 的大小是一致的。</p>
    <a class="edit" href="https://github.com/rust-zh/faq/blob/master/content/vec-new-ptr.md">编辑</a>
  </article>
  <div class="add-container">
    <a class="add" href="https://github.com/rust-zh/faq/tree/master/content">+ 贡献新条目</a>
  </div>
</main>
<footer>
  <a class="telegram" href="https://t.me/rust_zh">Rust 众</a>
  <a rel="license" class="cc0" href="https://creativecommons.org/publicdomain/zero/1.0/deed.zh">CC0</a>
</footer>
</html>
